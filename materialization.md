# 临时对象与实质化

这一篇我们重点关注纯右值。

当某些场合下，我们传入了纯右值表达式，但是期望一个对象来操作，比如：
- 将表达式绑定到引用——引用需要引用到一个对象；
- 访问子对象——比如数组的元素，或者类的成员；

那么这个时候纯右值表达式就不能直接上阵——因为之前说了，纯右值表达式不关联到一个对象，程序缺少“绑定引用的目标”或“访问子对象的来源”。那么这个时候就需要引入 **临时对象**。

临时对象（Temporary）是一种生命周期极短的对象。（生命周期……是另外一个复杂的话题了——指一个对象何时创建、何时初始化、何时消亡的时间范围，我们暂且按下不表；目前就按字面意思理解就好。）它只有在实在不得已需要用到时候才被创建，然后在 *全表达式* 求值结束后立即释放。

## 临时对象的创建

先来看创建。我们其实已经列举了最常见的两种创建临时对象的场合——将纯右值绑定到引用，以及访问纯右值所指代类型的某个子对象。

```cpp
const int& a = 42;     // 这个是绑定引用
struct S { int mem; };
S{}.mem;               // 这个是访问子对象
```

当写出这样的表达式的时候，C++ 程序就会创建一个临时对象来实现后续的行为。比如，引用 `a` 便引用（指代）了由 `42` 创建的临时对象，成为该对象的别名；`S{}` 纯右值表达式会创建一个 `S` 类型、具有零初始化的值的对象，随后 `.mem` 成员访问操作就可以访问到里面的值。

从纯右值创建临时对象的过程称作**临时量实质化**。临时量实质化的另一种说法是从纯右值到泛左值的转换：毕竟实质化了对象，得到的表达式就有关联的对象了，自然就归到泛左值的类别了。而且，`S{}.mem` 也是泛左值类型；因为 `S{}` 在 `.mem` 运算之前做了实质化——到泛左值的转换，访问子对象自然也是在有关联的对象的语境下发生的，`.mem` 就关联到了 `S{}` 实质化后得到的对象的成员子对象。

## 受保证复制消除

<details>
<summary>此节可跳过，点击展开详情。</summary>

接下来看一个复杂的例子。

```cpp
struct S{};
S byRef(const S& x) {
  return x;
}
S byVal(S x) {
  return S{};
}

int main() {
  byRef(S{});
  S result = byVal(S{});
  result = S{};
}
```

先来看对 `byRef` 的调用。`S{}` 是一个纯右值。但是它需要绑定到 `byRef` 的形参引用 `x` 上，因此发生临时量实质化，`x` 成为绑定到临时对象的引用。`byRef` 之后发生的事情暂且不管。

再来看 `byVal` 的调用。`S{}` 是一个纯右值，然后它要拿来初始化 `byVal` 的形参 `x`。但是注意标准引入了这么一句话：

> If the initializer expression is a prvalue and the cv-unqualified version of the source type is the same class as the class of the destination, the initializer expression is used to initialize the destination object. (N4860 [dcl.init.general/p16.6.1])

估计没人爱看英文，简单说就是，如果用来初始化类类型对象的表达式具有同类型的纯右值，那么就直接用这个纯右值的临时量实质化对象作为当前初始化的结果。换句话说，跳过了任何构造函数的调用；临时量实质化就得到了构造好的对象。

在这个例子中，本来应该用 `S{}` 调用预置的 `S(const S&);` 复制构造函数；但是由于 `S{}` 目前还是纯右值，所以直接将 `x` 定义为 `S{}` 实质化的结果。而 `S{}` 实质化得到的就是零初始化的 `S` 类型对象。我们就得到了 `x`。

`byVal` 返回的过程也是这样的。已知 `byVal(S{})` 也是纯右值表达式（返回非引用类型的函数的调用表达式是纯右值，我们之后会提到），然后同样地用纯右值初始化同类型对象，然后整个函数调用表达式直接实质化到 `result` 里面。那么这个表达式又是如何实质化成对象的？我们知道，函数返回时，使用 `return` 语句中的表达式来初始化调用表达式的结果对象。那么这个表达式就是 `return S{};` 里面的 `S{}`——又是一个纯右值，然后复制初始化又被跳过。经过这样两次特判的跳过后，结果就是 `S{}` 的实质化等价于 `byVal(S{})` 的实质化，然后等价于初始化了 `result`。

至于最后一行的例子，是在调用预置的 `S::operator=(const S&);`，这相当于将纯右值绑定到引用上，和第一行是一样的。这里列出只是展示“纯右值赋值”和“纯右值初始化”在标准叙述上的不同行为。

通过这个例子，可以看出纯右值在同类型的初始化时表现出**懒惰**特性，会不停跳过中间的构造函数调用，直到最后一刻才原位（in-place）实质化到目标对象里。在标准的这种规定下，整段代码不再需要 `S(const S&);`，你可以直接声明它为 `= delete`，此即**受保证的复制消除**的作用。

</details>

## 临时对象的释放（析构）

我们最开始说临时对象在 *全表达式* 执行完成的时刻释放。若该对象是类类型的，则调用析构函数。所谓**全表达式**的定义略微复杂，简单说就是不作为任何其他表达式的操作数的表达式。

```cpp
T d = a + T{} + c;
```
这里，表达式 `T{}` 是 `a + T{}` 的“子表达式”，所以 `T{}` 不是全表达式，并不在它实质化完成后立即析构，而是先执行 `a + T{}` 的求值。然后它也不是全表达式，因为 `a + T{}` 是 `a + T{} + c` 的子表达式。最终，`a + T{} + c` 才是全表达式，没有更上层的表达式在使用它作为操作数了。因此，在初始化完 `d` 之后，`T{}` 所实质化出来的临时对象会被析构。

**例外。** 当纯右值在初始化引用时，其实质化出的临时对象生命周期会被**延长**到引用在词法上的生命周期结束点。比如：

```cpp
{
  const int& a = 42;
  // 此时 a 指代的是 42 临时对象，它还没有释放
  // 可安全访问 a 所绑定的对象...
  std::println("{}\n", a); 
}
// a 退出词法作用域，此时释放 42
```

这个例外是不得已的设计，否则将纯右值绑定到引用将毫无意义——如果纯右值实质化出来的临时对象仍然是在全表达式求值完毕后释放，那么这个引用就立即悬垂了。在各种角度看，这都是反直觉的。

**例外的例外。** 在函数返回时发生的引用初始化，不会延长生命周期。

```cpp
const int& f() {
  return 42;
}

int main() {
  const int& a = f();
}
```

在这段代码中，`f()` 表达式的结果由 `42` 初始化；理论上是绑定到 `42` 实质化得到的临时对象的引用。但是，这个临时对象的生命周期没有被延长，它仍然是在全表达式执行完成析构——这里的全表达式就是 `return 42` 中的 `42`。因此，回到 `main` 后，`f()` 得到一个悬垂引用。进一步，`a` 也是悬垂引用了。

此外，这里还有一个常见的陷阱。考虑：

```cpp
struct B {};
struct A {
  B b;
  B& getB() {
    return b;
  }
};
A getA() {
  return A{};
}
int main() {
  // 加入你在某处看到了 auto&& 是“万能引用”的说辞
  // 然后不假思索地加以使用……
  auto&& b = getA().getB();
}
```

首先 `main` 里的 `b` 会被推导为 `B&` 类型——推导的事情之后再说，这里先关注后面的 `getA().getB()`。注意 `getA()` 返回的不是引用类型，因此它是一个纯右值。而且，`getA()` 这个纯右值没有绑定到引用，因此它采取“全表达式执行完成后就释放”的策略。全表达式是 `getA().getB()`，执行完后 `b` 绑定到了 `getA()` 实质化出来的临时对象的 `b` 成员。再然后，`getA()` 实质化出来的临时对象析构啦。然后，`b` 就悬垂了。

**警示。** 虽然引用可以延长临时对象的生命周期，但是它只会延长绑定到引用的临时对象。在表达式执行过程中产生的“中间”临时对象，还是会老老实实地立即释放。在写下引用声明前，务必仔细考虑这件事。

## 注释

- 本文中使用的“零初始化”是错误术语，应当使用“值初始化”。但是“值初始化”在文章中难以断句，故采用了错误的说法，借用“零初始化”来表示值初始化将简单类型成员初始化为 0 的特性。
- 关于延长临时对象生命周期的叙述使用了纯右值初始化引用；但是亡值直接初始化引用时也可能会被延长生命周期。这要求表达式符合一些形式，参考 [cppreference](https://en.cppreference.com/w/cpp/language/reference_initialization#Lifetime_of_a_temporary)。这可解释为什么 `auto&& x = foo().bar;` 不悬垂而 `auto&& x = foo().bar();` 会悬垂（后者不满足延长完整临时对象的表达式形式要求）。
